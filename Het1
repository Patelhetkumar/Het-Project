import yaml
import re
import os
import subprocess

# Define the pattern-to-group mapping
PATTERN_TO_GROUP = {
    r"laauau2efs.*": "l_aja_ausy01sr1",
    r"laauau1cefs.*": "l_aja_ausy02sr1",
    r"lcnkh01efs.*": "l_aja_cnhk01",
    r"lcnkh02efs.*": "l_aja_cnhk02",
    r"lcnkh03efs.*": "l_aja_cnhk03",
    r"lcnkh04efs.*": "l_aja_cnhk04",
    r"linin08efs.*": "l_aja_inmu08sr1",
    r"linin09efs.*": "l_aja_inmu09sr1",
    r"ljpna01efs.*": "l_aja_jpna01",
    r"ljpna02efs.*": "l_aja_jpna02",
    r"ljpna03efs.*": "l_aja_jpna03",
    r"lkrkr08efs.*": "l_aja_krse08sr2",
    r"lsgsg06efs.*": "l_aja_sgsg06",
    r"ltwpt04efs.*": "l_aja_twpt04",
    r"luktw09efs.*": "l_aja_twty09sr1",
    r"lukcm06efs.*": "l_emea_ukcm06",
    r"lrusil06efs.*": "l_amrs_usil06",
    r"luspa01efs.*": "l_amrs_uspa01",
    r"lusxa01efs.*": "l_amrs_usxa01",
    r"lusva01efs.*": "l_amrs_usva01"
}

# Define script directory
script_dir = os.path.dirname(os.path.abspath(__file__))
efs_file = os.path.join(script_dir, 'efsservers.txt')

# Generate efsservers.txt dynamically
cmd = f"efs display efsserver | sed -e '1,/^==*/d' | awk '{{print $2 \",\" $1 \",\" $3}}' > {efs_file}"
subprocess.run(cmd, shell=True, check=True)

# Load inventory YAML
inventory_file = os.path.join(script_dir, '..', 'prod', 'inventory.prod.yaml')
with open(inventory_file, 'r') as file:
    inventory1 = yaml.safe_load(file)

# Extract control and server group hosts
controlgroup_a1 = inventory1['all']['children']['controlgroup_a']['hosts']
controlgroup_b1 = inventory1['all']['children']['controlgroup_b']['hosts']

servertype_dev = set(inventory1['all']['children']['servertype_dev']['hosts'])
servertype_prod = set(inventory1['all']['children']['servertype_prod']['hosts'])

# Function to load unique EFS servers
def load_efs_unique_servers(efs_file):
    servers = {}
    with open(efs_file, 'r') as file:
        for line in file:
            parts = line.strip().split(',')
            if len(parts) < 3:
                continue  # Skip malformed lines
            server_name, cell_name, host_type = parts
            servers[server_name] = (cell_name, host_type)  # Ensure uniqueness
    return servers

# Function to load EFS servers
def load_efs_servers(efs_file):
    with open(efs_file, 'r') as file:
        return [line.strip().split(',') for line in file.readlines()]

# Load EFS servers
efs_servers1 = load_efs_unique_servers(efs_file)
efs_servers = load_efs_servers(efs_file)

# Function to determine group based on pattern
def determine_group_from_pattern(server_name):
    for pattern, group in PATTERN_TO_GROUP.items():
        if re.match(pattern, server_name):
            return group
    return "Unknown Group"

# Function to parse efsservers.txt and extract expected cells
def parse_efsservers(file_path):
    server_data = {}
    with open(file_path, "r") as file:
        for line in file:
            parts = line.strip().split(',')
            if len(parts) >= 3:
                server, cell, _ = parts
                if server not in server_data:
                    server_data[server] = set()
                server_data[server].add(cell)
    return server_data

# Function to parse inventory YAML
def parse_inventory(file_path):
    with open(file_path, "r") as file:
        inventory = yaml.safe_load(file)

    inventory_data = {}
    all_groups = inventory.get("all", {}).get("children", {})

    for group, group_data in all_groups.items():
        if group in PATTERN_TO_GROUP.values() and "hosts" in group_data and isinstance(group_data["hosts"], dict):
            for server, server_info in group_data["hosts"].items():
                inventory_data[server] = set(server_info.get("cells", []))

    return inventory_data

# Function to compare expected and actual cells
def compare_cells(efsservers_data, inventory_data):
    missing_servers = list(set(efsservers_data.keys()) - set(inventory_data.keys()))
    extra_servers = list(set(inventory_data.keys()) - set(efsservers_data.keys()))

    if missing_servers:
        print("\nMissing servers in inventory:")
        print("===============================================")
        for server in missing_servers:
            print(f"  - {server}")

    if extra_servers:
        print("\nServers found in ax_inventories but not in EFS Database or efsserver.txt:")
        print("===============================================")
        for server in extra_servers:
            print(f"  - {server}")

    for server, expected_cells in efsservers_data.items():
        group = determine_group_from_pattern(server)

        if not group:
            print(f"Warning: {server} does not match any known group.")
            continue

        actual_cells = inventory_data.get(server, set())

        if not actual_cells:
            print(f"\nMismatch for server: {server} in group {group}:")
            print("===============================================")
            print(f"  - EFS Database: {expected_cells}")
            print(f"  - Ax inventory: (New Server)")
            continue

        if expected_cells != actual_cells:
            missing_cells = expected_cells - actual_cells
            extra_cells = actual_cells - expected_cells

            print(f"\nMismatch for server: {server} in group {group}:")
            print("===============================================")
            print(f"  - EFS Database: {expected_cells}")
            print(f"  - Ax inventory: {actual_cells}")

            if missing_cells:
                print(f"  - Cells in the EFS Database but not in Ax inventory: {missing_cells}")

            if extra_cells:
                print(f"  - Cells in the Ax inventory but not in the EFS Database: {extra_cells}")

# Wrapper function to validate inventory with EFS
def validate_inventory_with_efs(inventory_file, efs_file):
    efsservers_data = parse_efsservers(efs_file)
    inventory_data = parse_inventory(inventory_file)
    compare_cells(efsservers_data, inventory_data)

# Call the function
validate_inventory_with_efs(inventory_file, efs_file)
